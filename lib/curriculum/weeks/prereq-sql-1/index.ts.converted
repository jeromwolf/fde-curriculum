import { Week } from '../../types'

export const prereqSql1Week: Week = {
  id: 'prereq-sql-1',
  phase: 0,
  week: 3,
  title: 'SQL 기초 1: 데이터 조회의 기본',
  slug: 'prereq-sql-1',
  description:
    'SQL의 기본 개념을 학습하고 SELECT, WHERE, ORDER BY를 활용한 데이터 조회를 마스터합니다.',
  duration: '1주',
  difficulty: 'beginner',
  topics: [
    '데이터베이스 기초 개념',
    'SQL 소개와 환경 설정',
    'SELECT 문과 열 선택',
    'WHERE 절과 조건 필터링',
    'ORDER BY와 정렬',
    'LIMIT와 DISTINCT',
    'SQL 내장 함수',
  ],
  learningObjectives: [
    '관계형 데이터베이스의 기본 개념을 이해한다',
    'SELECT 문으로 원하는 데이터를 조회할 수 있다',
    'WHERE 절로 조건에 맞는 데이터를 필터링할 수 있다',
    'ORDER BY로 결과를 정렬할 수 있다',
    'SQL 내장 함수를 활용할 수 있다',
  ],
  prerequisites: ['컴퓨터 기초 사용법'],
  tools: ['PostgreSQL 또는 SQLite', 'DBeaver 또는 DataGrip', 'SQL 온라인 편집기'],
  days: [
    // ========================================
    // Day 1: 데이터베이스 기초와 환경 설정
    // ========================================
    { slug: 'sql-day1',
      title: '데이터베이스 기초와 환경 설정',
      description:
        '관계형 데이터베이스의 개념을 이해하고 SQL 실습 환경을 구축합니다.',
      tasks: [
        // 1-1. 데이터베이스란?
        {
          id: 'prereq-sql-1-d1-t1',
          title: '데이터베이스 기초 개념',
          type: 'reading',
          duration: 30,
          points: 10,
          content: { markdown: `# 데이터베이스 기초 개념

## 데이터베이스란?

**데이터베이스(Database)**는 체계적으로 구조화된 데이터의 집합입니다.

### 왜 데이터베이스가 필요한가?

엑셀 파일로 데이터를 관리할 때의 문제점:
- 대용량 데이터 처리 어려움
- 여러 사람이 동시에 수정 불가
- 데이터 무결성 보장 어려움
- 복잡한 검색과 분석 한계

### 관계형 데이터베이스 (RDBMS)

데이터를 **테이블(Table)** 형태로 저장:

\` }\`\`
employees 테이블:
+----+--------+------------+--------+
| id | name   | department | salary |
+----+--------+------------+--------+
| 1  | 김철수 | 개발팀     | 5000   |
| 2  | 이영희 | 마케팅팀   | 4500   |
| 3  | 박민수 | 개발팀     | 5500   |
+----+--------+------------+--------+
\`\`\`

### 핵심 용어

| 용어 | 설명 | 엑셀 비유 |
|------|------|----------|
| 테이블 (Table) | 데이터를 저장하는 구조 | 시트 |
| 행 (Row) | 하나의 레코드/데이터 | 행 |
| 열 (Column) | 데이터의 속성 | 열 |
| 기본 키 (Primary Key) | 각 행을 고유하게 식별 | - |
| 외래 키 (Foreign Key) | 다른 테이블과의 관계 | - |

### 주요 RDBMS 종류

| 데이터베이스 | 특징 | 사용처 |
|-------------|------|--------|
| PostgreSQL | 오픈소스, 기능 풍부 | 웹 서비스, 분석 |
| MySQL | 오픈소스, 빠름 | 웹 서비스 |
| SQLite | 파일 기반, 가벼움 | 모바일, 임베디드 |
| Oracle | 엔터프라이즈급 | 대기업 |
| SQL Server | MS 제품 | 윈도우 환경 |

### SQL이란?

**SQL (Structured Query Language)**
- 데이터베이스와 대화하는 언어
- 1970년대 IBM에서 개발
- 거의 모든 RDBMS에서 표준으로 사용

SQL의 종류:
- **DDL** (Data Definition Language): CREATE, ALTER, DROP
- **DML** (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE
- **DCL** (Data Control Language): GRANT, REVOKE

이번 주는 **SELECT**에 집중합니다!`,
        },

        // 1-2. 환경 설정
        {
          id: 'prereq-sql-1-d1-t2',
          title: 'SQL 실습 환경 구축',
          type: 'reading',
          duration: 40,
          points: 15,
          content: { markdown: `# SQL 실습 환경 구축

## 옵션 1: 온라인 SQL 편집기 (추천 - 초보자)

### SQLite Online
- URL: https://sqliteonline.com/
- 설치 없이 바로 사용 가능
- 샘플 데이터 제공

### DB Fiddle
- URL: https://www.db-fiddle.com/
- PostgreSQL, MySQL 지원
- SQL 공유 가능

## 옵션 2: PostgreSQL 로컬 설치 (추천 - 실무)

### macOS
\` }\`\`bash
# Homebrew로 설치
brew install postgresql@15
brew services start postgresql@15

# 데이터베이스 생성
createdb mydb
\`\`\`

### Windows
1. https://www.postgresql.org/download/windows/ 다운로드
2. 설치 마법사 실행
3. 비밀번호 설정 (기억해두세요!)

## 옵션 3: DBeaver (GUI 도구)

### 설치
- URL: https://dbeaver.io/download/
- 무료 Community 버전 다운로드
- macOS, Windows, Linux 지원

### 연결 설정
1. 새 연결 만들기 (+ 버튼)
2. PostgreSQL 또는 SQLite 선택
3. 연결 정보 입력
4. Test Connection → 완료

## 실습용 데이터베이스 생성

### 샘플 테이블 생성
\`\`\`sql
-- employees 테이블
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department VARCHAR(50),
    salary INTEGER,
    hire_date DATE,
    email VARCHAR(100)
);

-- 샘플 데이터 삽입
INSERT INTO employees (name, department, salary, hire_date, email) VALUES
('김철수', '개발팀', 5000, '2020-03-15', 'kim@company.com'),
('이영희', '마케팅팀', 4500, '2019-07-01', 'lee@company.com'),
('박민수', '개발팀', 5500, '2018-11-20', 'park@company.com'),
('정수진', '인사팀', 4800, '2021-01-10', 'jung@company.com'),
('최동현', '개발팀', 6000, '2017-05-05', 'choi@company.com'),
('한미래', '마케팅팀', 4200, '2022-02-28', 'han@company.com'),
('송지원', '재무팀', 5200, '2019-09-15', 'song@company.com'),
('윤서준', '개발팀', 4800, '2021-06-01', 'yoon@company.com');

-- products 테이블
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    category VARCHAR(50),
    price INTEGER,
    stock INTEGER,
    created_at DATE
);

INSERT INTO products (name, category, price, stock, created_at) VALUES
('노트북', '전자기기', 1200000, 50, '2023-01-15'),
('키보드', '전자기기', 80000, 200, '2023-02-20'),
('마우스', '전자기기', 45000, 300, '2023-02-25'),
('모니터', '전자기기', 350000, 80, '2023-03-10'),
('책상', '가구', 250000, 30, '2023-04-05'),
('의자', '가구', 180000, 45, '2023-04-10'),
('책장', '가구', 150000, 25, '2023-05-15'),
('스탠드', '조명', 55000, 100, '2023-06-01');
\`\`\`

환경이 준비되었으면 첫 번째 SQL을 실행해봅시다!`,
        },

        // 1-3. 첫 번째 SQL 실행
        {
          id: 'prereq-sql-1-d1-t3',
          title: '첫 번째 SELECT 문 실행하기',
          type: 'code',
          duration: 30,
          points: 20,
          content: { markdown: `# 첫 번째 SELECT 문 실행하기

## 가장 기본적인 SELECT

모든 데이터 조회:
\` }\`\`sql
SELECT * FROM employees;
\`\`\`

\`*\`는 "모든 열"을 의미합니다.

### 결과:
\`\`\`
id | name   | department | salary | hire_date  | email
---+--------+------------+--------+------------+------------------
1  | 김철수 | 개발팀     | 5000   | 2020-03-15 | kim@company.com
2  | 이영희 | 마케팅팀   | 4500   | 2019-07-01 | lee@company.com
...
\`\`\`

## 특정 열만 선택

\`\`\`sql
SELECT name, department FROM employees;
\`\`\`

### 결과:
\`\`\`
name   | department
-------+-----------
김철수 | 개발팀
이영희 | 마케팅팀
...
\`\`\`

## SQL 작성 규칙

1. **대소문자**: 키워드는 대문자 권장 (SELECT, FROM)
2. **세미콜론**: 문장 끝에 \`;\` 붙이기
3. **공백/줄바꿈**: 가독성을 위해 자유롭게 사용

\`\`\`sql
-- 한 줄로 작성
SELECT name, salary FROM employees;

-- 여러 줄로 작성 (권장)
SELECT
    name,
    salary
FROM
    employees;
\`\`\`

## 실습 과제

다음 SQL을 실행해보세요:

1. products 테이블의 모든 데이터 조회
\`\`\`sql
SELECT * FROM products;
\`\`\`

2. products 테이블에서 name과 price만 조회
\`\`\`sql
SELECT name, price FROM products;
\`\`\`

3. employees 테이블에서 name, department, salary 조회
\`\`\`sql
SELECT name, department, salary FROM employees;
\`\`\``,
        },

        // 1-4. 퀴즈
        {
          id: 'prereq-sql-1-d1-t4',
          title: 'Day 1 퀴즈: 데이터베이스 기초',
          type: 'quiz',
          duration: 10,
          points: 15,
          content: { markdown: `# Day 1 퀴즈

데이터베이스 기초 개념을 확인합니다.` },
          quiz: {
            questions: [
              {
                id: 'q1',
                question: '관계형 데이터베이스에서 하나의 데이터 레코드를 무엇이라 하나요?',
                options: ['열 (Column)', '행 (Row)', '테이블 (Table)', '스키마 (Schema)'],
                correctAnswer: 1,
                explanation:
                  '행(Row)은 하나의 데이터 레코드를 의미합니다. 열(Column)은 데이터의 속성입니다.',
              },
              {
                id: 'q2',
                question: 'SELECT * FROM employees; 에서 * 의 의미는?',
                options: ['첫 번째 열만', '모든 열', '모든 행', '랜덤 선택'],
                correctAnswer: 1,
                explanation: '* (asterisk)는 테이블의 모든 열을 선택한다는 의미입니다.',
              },
              {
                id: 'q3',
                question: 'SQL에서 SELECT 문은 어떤 종류의 SQL에 속하나요?',
                options: ['DDL', 'DML', 'DCL', 'TCL'],
                correctAnswer: 1,
                explanation:
                  'SELECT는 DML(Data Manipulation Language)에 속합니다. 데이터를 조회/조작하는 명령어입니다.',
              },
              {
                id: 'q4',
                question: '다음 중 오픈소스 RDBMS가 아닌 것은?',
                options: ['PostgreSQL', 'MySQL', 'Oracle', 'SQLite'],
                correctAnswer: 2,
                explanation:
                  'Oracle은 상용 데이터베이스입니다. PostgreSQL, MySQL, SQLite는 오픈소스입니다.',
              },
            ],
          },
        },
      ],
    },

    // ========================================
    // Day 2: SELECT 문 심화
    // ========================================
    { slug: 'sql-day2',
      title: 'SELECT 문 심화: 별칭과 연산',
      description: '열 별칭(Alias)을 사용하고 SELECT에서 연산을 수행합니다.',
      tasks: [
        // 2-1. 열 별칭 (Alias)
        {
          id: 'prereq-sql-1-d2-t1',
          title: '열 별칭 (Column Alias)',
          type: 'reading',
          duration: 25,
          points: 10,
          content: { markdown: `# 열 별칭 (Column Alias)

## 별칭이란?

조회 결과의 열 이름을 원하는 이름으로 변경합니다.

### 기본 문법
\` }\`\`sql
SELECT 열이름 AS 별칭 FROM 테이블;
\`\`\`

### 예제
\`\`\`sql
-- 별칭 없이
SELECT name, salary FROM employees;
-- 결과: name | salary

-- 별칭 사용
SELECT name AS 이름, salary AS 급여 FROM employees;
-- 결과: 이름 | 급여
\`\`\`

## AS 생략 가능

\`\`\`sql
-- AS 사용
SELECT name AS 이름 FROM employees;

-- AS 생략 (동일한 결과)
SELECT name 이름 FROM employees;
\`\`\`

## 공백이 포함된 별칭

큰따옴표 또는 대괄호 사용:
\`\`\`sql
-- PostgreSQL, MySQL
SELECT name AS "직원 이름" FROM employees;

-- SQL Server
SELECT name AS [직원 이름] FROM employees;
\`\`\`

## 별칭 활용 사례

### 1. 가독성 향상
\`\`\`sql
SELECT
    e.name AS employee_name,
    e.department AS dept,
    e.salary AS monthly_salary
FROM employees e;
\`\`\`

### 2. 계산 결과에 이름 부여
\`\`\`sql
SELECT
    name,
    salary,
    salary * 12 AS annual_salary
FROM employees;
\`\`\`

### 3. 테이블 별칭
\`\`\`sql
-- 테이블에도 별칭 사용 가능
SELECT e.name, e.salary
FROM employees AS e;

-- AS 생략
SELECT e.name, e.salary
FROM employees e;
\`\`\``,
        },

        // 2-2. SELECT에서 연산
        {
          id: 'prereq-sql-1-d2-t2',
          title: 'SELECT에서 연산하기',
          type: 'reading',
          duration: 30,
          points: 15,
          content: { markdown: `# SELECT에서 연산하기

## 산술 연산자

| 연산자 | 의미 | 예제 |
|--------|------|------|
| + | 덧셈 | salary + 1000 |
| - | 뺄셈 | salary - 500 |
| * | 곱셈 | salary * 12 |
| / | 나눗셈 | salary / 30 |
| % | 나머지 | salary % 100 |

### 예제: 급여 계산
\` }\`\`sql
SELECT
    name,
    salary AS 월급,
    salary * 12 AS 연봉,
    salary * 12 * 0.1 AS 연간세금
FROM employees;
\`\`\`

### 결과:
\`\`\`
name   | 월급 | 연봉  | 연간세금
-------+------+-------+---------
김철수 | 5000 | 60000 | 6000
이영희 | 4500 | 54000 | 5400
\`\`\`

## 문자열 연결

### PostgreSQL / SQLite
\`\`\`sql
SELECT name || ' (' || department || ')' AS 직원정보
FROM employees;
-- 결과: 김철수 (개발팀)
\`\`\`

### MySQL
\`\`\`sql
SELECT CONCAT(name, ' (', department, ')') AS 직원정보
FROM employees;
\`\`\`

## NULL 처리

NULL은 "값이 없음"을 의미:
\`\`\`sql
-- NULL과의 연산 결과는 NULL
SELECT 5 + NULL;  -- 결과: NULL

-- COALESCE로 기본값 설정
SELECT COALESCE(salary, 0) FROM employees;
\`\`\`

## 실습: 상품 가격 계산
\`\`\`sql
SELECT
    name AS 상품명,
    price AS 원가,
    price * 1.1 AS "부가세 포함",
    price * 0.9 AS "10% 할인가",
    stock AS 재고,
    price * stock AS 재고가치
FROM products;
\`\`\``,
        },

        // 2-3. 실습
        {
          id: 'prereq-sql-1-d2-t3',
          title: '별칭과 연산 실습',
          type: 'code',
          duration: 35,
          points: 25,
          content: { markdown: `# 별칭과 연산 실습

## 실습 1: 직원 연봉 계산

다음 요구사항을 만족하는 SQL을 작성하세요:
- employees 테이블에서 조회
- name을 "직원명"으로 표시
- salary를 "월급"으로 표시
- 연봉 (월급 * 12) 계산
- 세후 연봉 (연봉 * 0.9) 계산

\` }\`\`sql
SELECT
    name AS 직원명,
    salary AS 월급,
    salary * 12 AS 연봉,
    salary * 12 * 0.9 AS "세후 연봉"
FROM employees;
\`\`\`

## 실습 2: 상품 재고 분석

products 테이블에서:
- 상품명, 카테고리 조회
- 단가에 부가세 10% 추가한 가격
- 재고 수량
- 재고 총 가치 (단가 * 재고)

\`\`\`sql
SELECT
    name AS 상품명,
    category AS 카테고리,
    price AS 단가,
    price * 1.1 AS "부가세 포함가",
    stock AS 재고수량,
    price * stock AS 재고가치
FROM products;
\`\`\`

## 실습 3: 직원 정보 문자열 결합

PostgreSQL/SQLite:
\`\`\`sql
SELECT
    name || ' - ' || department AS 직원정보,
    '₩' || (salary * 10000) AS 급여표시
FROM employees;
\`\`\`

## 도전 과제

1. employees에서 일급(월급/30) 계산하기
2. products에서 20% 할인된 가격 계산하기
3. 직원 이름과 이메일을 결합하여 표시하기`,
        },

        // 2-4. 퀴즈
        {
          id: 'prereq-sql-1-d2-t4',
          title: 'Day 2 퀴즈: 별칭과 연산',
          type: 'quiz',
          duration: 10,
          points: 15,
          content: { markdown: `# Day 2 퀴즈` },
          quiz: {
            questions: [
              {
                id: 'q1',
                question: 'SELECT name AS 이름 FROM employees; 에서 AS의 역할은?',
                options: ['테이블 조인', '열 이름 변경', '조건 필터링', '정렬'],
                correctAnswer: 1,
                explanation: 'AS는 열에 별칭(Alias)을 부여하여 결과에서 다른 이름으로 표시합니다.',
              },
              {
                id: 'q2',
                question: 'SELECT salary * 12 FROM employees; 의 결과는?',
                options: [
                  '에러 발생',
                  '문자열 12번 반복',
                  '급여의 12배 (연봉)',
                  '12개 행만 표시',
                ],
                correctAnswer: 2,
                explanation: 'SELECT에서 산술 연산이 가능합니다. salary * 12는 연봉 계산입니다.',
              },
              {
                id: 'q3',
                question: 'SELECT 5 + NULL의 결과는?',
                options: ['5', '0', 'NULL', '에러'],
                correctAnswer: 2,
                explanation: 'NULL과의 모든 연산 결과는 NULL입니다. NULL은 값이 없음을 의미합니다.',
              },
              {
                id: 'q4',
                question: 'PostgreSQL에서 문자열을 연결하는 연산자는?',
                options: ['+', '&', '||', 'CONCAT만 가능'],
                correctAnswer: 2,
                explanation:
                  'PostgreSQL과 SQLite에서는 || 연산자로 문자열을 연결합니다. MySQL은 CONCAT 함수를 사용합니다.',
              },
            ],
          },
        },
      ],
    },

    // ========================================
    // Day 3: WHERE 절
    // ========================================
    { slug: 'sql-day3',
      title: 'WHERE 절: 조건으로 필터링',
      description: 'WHERE 절을 사용하여 원하는 조건의 데이터만 조회합니다.',
      tasks: [
        // 3-1. WHERE 기초
        {
          id: 'prereq-sql-1-d3-t1',
          title: 'WHERE 절 기초',
          type: 'reading',
          duration: 30,
          points: 15,
          content: { markdown: `# WHERE 절 기초

## WHERE 절이란?

조건에 맞는 행만 선택하여 조회합니다.

### 기본 문법
\` }\`\`sql
SELECT 열 FROM 테이블 WHERE 조건;
\`\`\`

### 예제
\`\`\`sql
-- 개발팀 직원만 조회
SELECT * FROM employees WHERE department = '개발팀';

-- 급여가 5000 이상인 직원
SELECT * FROM employees WHERE salary >= 5000;
\`\`\`

## 비교 연산자

| 연산자 | 의미 | 예제 |
|--------|------|------|
| = | 같다 | department = '개발팀' |
| <> 또는 != | 같지 않다 | department <> '개발팀' |
| > | 크다 | salary > 5000 |
| < | 작다 | salary < 5000 |
| >= | 크거나 같다 | salary >= 5000 |
| <= | 작거나 같다 | salary <= 5000 |

### 문자열 비교
\`\`\`sql
-- 문자열은 작은따옴표 사용
SELECT * FROM employees WHERE name = '김철수';

-- 대소문자 구분 (DB에 따라 다름)
SELECT * FROM employees WHERE department = '개발팀';
\`\`\`

### 숫자 비교
\`\`\`sql
-- 숫자는 따옴표 없이
SELECT * FROM employees WHERE salary > 5000;

-- 범위 조회
SELECT * FROM employees WHERE salary >= 4500 AND salary <= 5500;
\`\`\`

### 날짜 비교
\`\`\`sql
-- 날짜도 비교 가능
SELECT * FROM employees WHERE hire_date > '2020-01-01';

-- 특정 연도 입사자
SELECT * FROM employees WHERE hire_date >= '2021-01-01' AND hire_date < '2022-01-01';
\`\`\`

## 실행 순서

1. FROM: 테이블 선택
2. **WHERE**: 조건 필터링
3. SELECT: 열 선택

\`\`\`sql
SELECT name, salary    -- 3. 열 선택
FROM employees         -- 1. 테이블에서
WHERE salary > 5000;   -- 2. 조건에 맞는 행만
\`\`\``,
        },

        // 3-2. 논리 연산자
        {
          id: 'prereq-sql-1-d3-t2',
          title: '논리 연산자: AND, OR, NOT',
          type: 'reading',
          duration: 30,
          points: 15,
          content: { markdown: `# 논리 연산자: AND, OR, NOT

## AND 연산자

**모든 조건**이 참이어야 선택됩니다.

\` }\`\`sql
-- 개발팀이면서 급여 5000 이상
SELECT * FROM employees
WHERE department = '개발팀' AND salary >= 5000;
\`\`\`

### 결과:
\`\`\`
id | name   | department | salary
---+--------+------------+-------
3  | 박민수 | 개발팀     | 5500
5  | 최동현 | 개발팀     | 6000
\`\`\`

## OR 연산자

**하나 이상**의 조건이 참이면 선택됩니다.

\`\`\`sql
-- 개발팀이거나 마케팅팀
SELECT * FROM employees
WHERE department = '개발팀' OR department = '마케팅팀';
\`\`\`

## NOT 연산자

조건을 **부정**합니다.

\`\`\`sql
-- 개발팀이 아닌 직원
SELECT * FROM employees
WHERE NOT department = '개발팀';

-- 동일한 결과
SELECT * FROM employees
WHERE department <> '개발팀';
\`\`\`

## 복합 조건

괄호로 우선순위를 지정합니다:

\`\`\`sql
-- 개발팀이면서 (급여 5000 이상이거나 2020년 이후 입사)
SELECT * FROM employees
WHERE department = '개발팀'
  AND (salary >= 5000 OR hire_date >= '2020-01-01');
\`\`\`

### 우선순위
1. NOT
2. AND
3. OR

⚠️ 복잡한 조건은 반드시 괄호 사용!

\`\`\`sql
-- 잘못된 예: 의도와 다른 결과
SELECT * FROM employees
WHERE department = '개발팀' OR department = '마케팅팀' AND salary > 5000;
-- 실제 의미: 개발팀 전체 OR (마케팅팀 AND 급여 5000 초과)

-- 올바른 예
SELECT * FROM employees
WHERE (department = '개발팀' OR department = '마케팅팀') AND salary > 5000;
\`\`\``,
        },

        // 3-3. 특수 연산자
        {
          id: 'prereq-sql-1-d3-t3',
          title: '특수 연산자: IN, BETWEEN, LIKE, IS NULL',
          type: 'reading',
          duration: 35,
          points: 20,
          content: { markdown: `# 특수 연산자

## IN 연산자

여러 값 중 하나와 일치하는지 확인합니다.

\` }\`\`sql
-- OR을 여러 번 쓰는 대신
SELECT * FROM employees
WHERE department = '개발팀' OR department = '마케팅팀' OR department = '재무팀';

-- IN 사용 (더 간결)
SELECT * FROM employees
WHERE department IN ('개발팀', '마케팅팀', '재무팀');
\`\`\`

### NOT IN
\`\`\`sql
-- 개발팀, 마케팅팀 제외
SELECT * FROM employees
WHERE department NOT IN ('개발팀', '마케팅팀');
\`\`\`

## BETWEEN 연산자

범위 내의 값을 선택합니다 (경계값 포함).

\`\`\`sql
-- 급여 4500 이상 5500 이하
SELECT * FROM employees
WHERE salary BETWEEN 4500 AND 5500;

-- 동일한 결과
SELECT * FROM employees
WHERE salary >= 4500 AND salary <= 5500;
\`\`\`

### 날짜 범위
\`\`\`sql
-- 2020년 입사자
SELECT * FROM employees
WHERE hire_date BETWEEN '2020-01-01' AND '2020-12-31';
\`\`\`

## LIKE 연산자

패턴 매칭으로 문자열을 검색합니다.

| 와일드카드 | 의미 | 예제 |
|-----------|------|------|
| % | 0개 이상의 문자 | '김%' → 김으로 시작 |
| _ | 정확히 1개 문자 | '김_' → 김X (2글자) |

\`\`\`sql
-- 김으로 시작하는 이름
SELECT * FROM employees WHERE name LIKE '김%';

-- 팀으로 끝나는 부서
SELECT * FROM employees WHERE department LIKE '%팀';

-- 이름에 '수' 포함
SELECT * FROM employees WHERE name LIKE '%수%';

-- 이메일이 company.com
SELECT * FROM employees WHERE email LIKE '%@company.com';
\`\`\`

## IS NULL / IS NOT NULL

NULL 값을 확인합니다.

\`\`\`sql
-- 이메일이 없는 직원
SELECT * FROM employees WHERE email IS NULL;

-- 이메일이 있는 직원
SELECT * FROM employees WHERE email IS NOT NULL;
\`\`\`

⚠️ NULL 비교는 반드시 IS NULL / IS NOT NULL 사용!
\`\`\`sql
-- 잘못된 예 (결과 없음)
SELECT * FROM employees WHERE email = NULL;

-- 올바른 예
SELECT * FROM employees WHERE email IS NULL;
\`\`\``,
        },

        // 3-4. 실습
        {
          id: 'prereq-sql-1-d3-t4',
          title: 'WHERE 절 실습',
          type: 'code',
          duration: 30,
          points: 25,
          content: { markdown: `# WHERE 절 실습

## 실습 1: 기본 조건

\` }\`\`sql
-- 1. 개발팀 직원 조회
SELECT * FROM employees WHERE department = '개발팀';

-- 2. 급여 5000 이상인 직원
SELECT name, salary FROM employees WHERE salary >= 5000;

-- 3. 2021년 이후 입사자
SELECT * FROM employees WHERE hire_date >= '2021-01-01';
\`\`\`

## 실습 2: 복합 조건

\`\`\`sql
-- 1. 개발팀이면서 급여 5000 이상
SELECT * FROM employees
WHERE department = '개발팀' AND salary >= 5000;

-- 2. 개발팀이거나 마케팅팀
SELECT * FROM employees
WHERE department IN ('개발팀', '마케팅팀');

-- 3. 급여 4500~5500 사이
SELECT * FROM employees
WHERE salary BETWEEN 4500 AND 5500;
\`\`\`

## 실습 3: 패턴 매칭

\`\`\`sql
-- 1. 이름이 '김'으로 시작
SELECT * FROM employees WHERE name LIKE '김%';

-- 2. 이메일에 'company' 포함
SELECT * FROM employees WHERE email LIKE '%company%';

-- 3. 전자기기 카테고리 상품
SELECT * FROM products WHERE category = '전자기기';
\`\`\`

## 실습 4: 상품 필터링

\`\`\`sql
-- 1. 가격 10만원 이상 상품
SELECT * FROM products WHERE price >= 100000;

-- 2. 재고 50개 이하 상품
SELECT name, stock FROM products WHERE stock <= 50;

-- 3. 가구 카테고리에서 20만원 이하
SELECT * FROM products
WHERE category = '가구' AND price <= 200000;
\`\`\`

## 도전 과제

1. 개발팀이 아닌 직원 중 급여 5000 미만인 사람
2. 2019~2020년 사이 입사한 직원
3. 이름에 '수'가 포함된 직원`,
        },

        // 3-5. 퀴즈
        {
          id: 'prereq-sql-1-d3-t5',
          title: 'Day 3 퀴즈: WHERE 절',
          type: 'quiz',
          duration: 10,
          points: 15,
          content: { markdown: `# Day 3 퀴즈` },
          quiz: {
            questions: [
              {
                id: 'q1',
                question:
                  "department IN ('개발팀', '마케팅팀')과 동일한 결과를 내는 조건은?",
                options: [
                  "department = '개발팀' AND department = '마케팅팀'",
                  "department = '개발팀' OR department = '마케팅팀'",
                  "department BETWEEN '개발팀' AND '마케팅팀'",
                  "department LIKE '개발팀%'",
                ],
                correctAnswer: 1,
                explanation:
                  'IN은 여러 OR 조건을 간결하게 표현합니다. IN은 OR과 동일한 결과를 냅니다.',
              },
              {
                id: 'q2',
                question: 'salary BETWEEN 4000 AND 5000에서 salary가 5000이면?',
                options: [
                  '선택되지 않음',
                  '선택됨',
                  '에러 발생',
                  '5000 미만만 선택',
                ],
                correctAnswer: 1,
                explanation:
                  'BETWEEN은 경계값을 포함합니다. 4000 이상 5000 이하가 선택됩니다.',
              },
              {
                id: 'q3',
                question: "name LIKE '김%'는 어떤 이름을 찾나요?",
                options: [
                  '김으로 끝나는 이름',
                  '김을 포함하는 이름',
                  '김으로 시작하는 이름',
                  '정확히 김만',
                ],
                correctAnswer: 2,
                explanation:
                  '%는 0개 이상의 문자를 의미합니다. 김% 는 김으로 시작하는 모든 문자열을 찾습니다.',
              },
              {
                id: 'q4',
                question: 'NULL 값을 확인하는 올바른 방법은?',
                options: [
                  'column = NULL',
                  "column = 'NULL'",
                  'column IS NULL',
                  'column == NULL',
                ],
                correctAnswer: 2,
                explanation:
                  'NULL은 IS NULL 또는 IS NOT NULL로만 비교할 수 있습니다. = NULL은 작동하지 않습니다.',
              },
            ],
          },
        },
      ],
    },

    // ========================================
    // Day 4: ORDER BY, LIMIT, DISTINCT
    // ========================================
    { slug: 'sql-day4',
      title: 'ORDER BY, LIMIT, DISTINCT',
      description: '결과를 정렬하고 중복을 제거하며 결과 수를 제한합니다.',
      tasks: [
        // 4-1. ORDER BY
        {
          id: 'prereq-sql-1-d4-t1',
          title: 'ORDER BY: 결과 정렬',
          type: 'reading',
          duration: 30,
          points: 15,
          content: { markdown: `# ORDER BY: 결과 정렬

## 기본 문법

\` }\`\`sql
SELECT 열 FROM 테이블 ORDER BY 열 [ASC|DESC];
\`\`\`

- **ASC**: 오름차순 (기본값, 생략 가능)
- **DESC**: 내림차순

## 오름차순 정렬

\`\`\`sql
-- 급여 오름차순 (낮은 것부터)
SELECT name, salary FROM employees ORDER BY salary;

-- ASC 명시 (동일)
SELECT name, salary FROM employees ORDER BY salary ASC;
\`\`\`

### 결과:
\`\`\`
name   | salary
-------+-------
한미래 | 4200
이영희 | 4500
정수진 | 4800
...
\`\`\`

## 내림차순 정렬

\`\`\`sql
-- 급여 내림차순 (높은 것부터)
SELECT name, salary FROM employees ORDER BY salary DESC;
\`\`\`

### 결과:
\`\`\`
name   | salary
-------+-------
최동현 | 6000
박민수 | 5500
송지원 | 5200
...
\`\`\`

## 여러 열로 정렬

\`\`\`sql
-- 부서별 오름차순, 같은 부서 내에서 급여 내림차순
SELECT name, department, salary
FROM employees
ORDER BY department ASC, salary DESC;
\`\`\`

### 결과:
\`\`\`
name   | department | salary
-------+------------+-------
최동현 | 개발팀     | 6000
박민수 | 개발팀     | 5500
김철수 | 개발팀     | 5000
이영희 | 마케팅팀   | 4500
한미래 | 마케팅팀   | 4200
...
\`\`\`

## 열 번호로 정렬

\`\`\`sql
-- SELECT의 첫 번째 열로 정렬
SELECT name, salary FROM employees ORDER BY 1;

-- 두 번째 열(salary)로 정렬
SELECT name, salary FROM employees ORDER BY 2 DESC;
\`\`\`

⚠️ 열 번호 사용은 권장하지 않음 (가독성 저하)

## 날짜 정렬

\`\`\`sql
-- 최근 입사자부터
SELECT name, hire_date FROM employees ORDER BY hire_date DESC;

-- 오래된 입사자부터
SELECT name, hire_date FROM employees ORDER BY hire_date ASC;
\`\`\`

## NULL 값 정렬

PostgreSQL:
\`\`\`sql
-- NULL을 마지막에
ORDER BY column NULLS LAST;

-- NULL을 처음에
ORDER BY column NULLS FIRST;
\`\`\``,
        },

        // 4-2. LIMIT
        {
          id: 'prereq-sql-1-d4-t2',
          title: 'LIMIT: 결과 수 제한',
          type: 'reading',
          duration: 25,
          points: 10,
          content: { markdown: `# LIMIT: 결과 수 제한

## 기본 문법

\` }\`\`sql
SELECT 열 FROM 테이블 LIMIT 개수;
\`\`\`

## 상위 N개 조회

\`\`\`sql
-- 상위 3명
SELECT * FROM employees LIMIT 3;

-- 급여 상위 5명
SELECT name, salary
FROM employees
ORDER BY salary DESC
LIMIT 5;
\`\`\`

## OFFSET: 건너뛰기

\`\`\`sql
-- 처음 2개 건너뛰고 3개 조회
SELECT * FROM employees LIMIT 3 OFFSET 2;
\`\`\`

### 페이지네이션 구현

\`\`\`sql
-- 1페이지 (1~10번)
SELECT * FROM employees ORDER BY id LIMIT 10 OFFSET 0;

-- 2페이지 (11~20번)
SELECT * FROM employees ORDER BY id LIMIT 10 OFFSET 10;

-- 3페이지 (21~30번)
SELECT * FROM employees ORDER BY id LIMIT 10 OFFSET 20;

-- 공식: OFFSET = (페이지번호 - 1) * LIMIT
\`\`\`

## 실용적 예제

\`\`\`sql
-- 가장 비싼 상품 3개
SELECT name, price
FROM products
ORDER BY price DESC
LIMIT 3;

-- 최근 입사한 직원 5명
SELECT name, hire_date
FROM employees
ORDER BY hire_date DESC
LIMIT 5;

-- 재고가 가장 적은 상품 3개
SELECT name, stock
FROM products
ORDER BY stock ASC
LIMIT 3;
\`\`\`

## SQL Server/Oracle (참고)

SQL Server:
\`\`\`sql
SELECT TOP 5 * FROM employees;
\`\`\`

Oracle:
\`\`\`sql
SELECT * FROM employees WHERE ROWNUM <= 5;
-- 또는 (12c 이상)
SELECT * FROM employees FETCH FIRST 5 ROWS ONLY;
\`\`\``,
        },

        // 4-3. DISTINCT
        {
          id: 'prereq-sql-1-d4-t3',
          title: 'DISTINCT: 중복 제거',
          type: 'reading',
          duration: 25,
          points: 10,
          content: { markdown: `# DISTINCT: 중복 제거

## 기본 문법

\` }\`\`sql
SELECT DISTINCT 열 FROM 테이블;
\`\`\`

## 단일 열 중복 제거

\`\`\`sql
-- 모든 부서 목록 (중복 포함)
SELECT department FROM employees;
-- 결과: 개발팀, 마케팅팀, 개발팀, 인사팀, 개발팀, 마케팅팀, 재무팀, 개발팀

-- 고유한 부서 목록
SELECT DISTINCT department FROM employees;
-- 결과: 개발팀, 마케팅팀, 인사팀, 재무팀
\`\`\`

## 여러 열 중복 제거

\`\`\`sql
-- 부서와 급여 조합의 고유값
SELECT DISTINCT department, salary FROM employees;
\`\`\`

### 결과:
같은 부서에서 같은 급여를 받는 경우만 중복으로 처리

## DISTINCT와 정렬

\`\`\`sql
-- 고유한 카테고리를 알파벳 순으로
SELECT DISTINCT category
FROM products
ORDER BY category;
\`\`\`

## 실용적 예제

\`\`\`sql
-- 직원들이 속한 고유 부서 목록
SELECT DISTINCT department FROM employees ORDER BY department;

-- 상품 카테고리 목록
SELECT DISTINCT category FROM products;

-- 존재하는 급여 레벨
SELECT DISTINCT salary FROM employees ORDER BY salary;

-- 부서별 고유 급여 조합
SELECT DISTINCT department, salary
FROM employees
ORDER BY department, salary;
\`\`\`

## COUNT와 DISTINCT

\`\`\`sql
-- 총 직원 수
SELECT COUNT(*) FROM employees;  -- 8

-- 고유 부서 수
SELECT COUNT(DISTINCT department) FROM employees;  -- 4

-- 고유 급여 레벨 수
SELECT COUNT(DISTINCT salary) FROM employees;
\`\`\`

## 주의사항

- DISTINCT는 전체 결과에 적용됩니다
- 성능에 영향을 줄 수 있음 (대량 데이터 시)
- NULL도 하나의 고유값으로 취급됩니다`,
        },

        // 4-4. 실습
        {
          id: 'prereq-sql-1-d4-t4',
          title: 'ORDER BY, LIMIT, DISTINCT 실습',
          type: 'code',
          duration: 30,
          points: 25,
          content: { markdown: `# ORDER BY, LIMIT, DISTINCT 실습

## 실습 1: 정렬

\` }\`\`sql
-- 1. 급여 높은 순으로 직원 조회
SELECT name, salary
FROM employees
ORDER BY salary DESC;

-- 2. 부서별로 정렬, 같은 부서는 이름순
SELECT name, department
FROM employees
ORDER BY department, name;

-- 3. 상품을 가격 순으로 정렬
SELECT name, price
FROM products
ORDER BY price DESC;
\`\`\`

## 실습 2: LIMIT

\`\`\`sql
-- 1. 급여 상위 3명
SELECT name, salary
FROM employees
ORDER BY salary DESC
LIMIT 3;

-- 2. 가장 오래 근무한 직원 5명
SELECT name, hire_date
FROM employees
ORDER BY hire_date ASC
LIMIT 5;

-- 3. 가장 비싼 상품 3개
SELECT name, price
FROM products
ORDER BY price DESC
LIMIT 3;
\`\`\`

## 실습 3: DISTINCT

\`\`\`sql
-- 1. 고유 부서 목록
SELECT DISTINCT department FROM employees;

-- 2. 고유 카테고리 목록
SELECT DISTINCT category FROM products;

-- 3. 부서 수 카운트
SELECT COUNT(DISTINCT department) AS 부서수 FROM employees;
\`\`\`

## 실습 4: 복합 활용

\`\`\`sql
-- 1. 개발팀 직원 중 급여 상위 2명
SELECT name, salary
FROM employees
WHERE department = '개발팀'
ORDER BY salary DESC
LIMIT 2;

-- 2. 전자기기 카테고리에서 가장 저렴한 상품
SELECT name, price
FROM products
WHERE category = '전자기기'
ORDER BY price ASC
LIMIT 1;

-- 3. 2020년 이후 입사자 중 최근 3명
SELECT name, hire_date
FROM employees
WHERE hire_date >= '2020-01-01'
ORDER BY hire_date DESC
LIMIT 3;
\`\`\`

## 도전 과제

1. 급여 4~6위 직원 조회 (OFFSET 사용)
2. 각 카테고리별 가장 비싼 상품 조회 (아직 안 배웠지만 시도해보세요!)`,
        },

        // 4-5. 퀴즈
        {
          id: 'prereq-sql-1-d4-t5',
          title: 'Day 4 퀴즈',
          type: 'quiz',
          duration: 10,
          points: 15,
          content: { markdown: `# Day 4 퀴즈` },
          quiz: {
            questions: [
              {
                id: 'q1',
                question: 'ORDER BY salary DESC의 의미는?',
                options: [
                  '급여 오름차순',
                  '급여 내림차순',
                  '급여로 그룹화',
                  '급여 중복 제거',
                ],
                correctAnswer: 1,
                explanation: 'DESC는 내림차순(Descending)입니다. 높은 값부터 낮은 값 순서로 정렬합니다.',
              },
              {
                id: 'q2',
                question: 'LIMIT 5 OFFSET 10의 의미는?',
                options: [
                  '처음 5개 결과',
                  '10개 건너뛰고 5개',
                  '5개 건너뛰고 10개',
                  '5번째부터 10번째까지',
                ],
                correctAnswer: 1,
                explanation:
                  'OFFSET 10은 처음 10개를 건너뛰고, LIMIT 5는 그 이후 5개를 가져옵니다. 즉 11~15번째 결과입니다.',
              },
              {
                id: 'q3',
                question: 'SELECT DISTINCT department FROM employees의 결과는?',
                options: [
                  '모든 직원의 부서',
                  '중복 없는 고유 부서 목록',
                  '부서별 직원 수',
                  '에러',
                ],
                correctAnswer: 1,
                explanation: 'DISTINCT는 중복을 제거하여 고유한 값만 반환합니다.',
              },
              {
                id: 'q4',
                question: 'ORDER BY 1의 의미는?',
                options: [
                  'id가 1인 행만',
                  '첫 번째 행만',
                  'SELECT의 첫 번째 열로 정렬',
                  '1씩 증가하며 정렬',
                ],
                correctAnswer: 2,
                explanation: 'ORDER BY에서 숫자는 SELECT 절의 열 위치를 의미합니다. 1은 첫 번째 열입니다.',
              },
            ],
          },
        },
      ],
    },

    // ========================================
    // Day 5: SQL 내장 함수와 주간 프로젝트
    // ========================================
    { slug: 'sql-day5',
      title: 'SQL 내장 함수와 주간 프로젝트',
      description: '문자열, 숫자, 날짜 함수를 학습하고 주간 프로젝트를 완성합니다.',
      tasks: [
        // 5-1. 문자열 함수
        {
          id: 'prereq-sql-1-d5-t1',
          title: '문자열 함수',
          type: 'reading',
          duration: 25,
          points: 15,
          content: { markdown: `# 문자열 함수

## 대소문자 변환

\` }\`\`sql
-- 대문자로
SELECT UPPER(name) FROM employees;
-- 결과: 김철수 → 김철수 (한글은 영향 없음)
SELECT UPPER(email) FROM employees;
-- 결과: KIM@COMPANY.COM

-- 소문자로
SELECT LOWER(email) FROM employees;
-- 결과: kim@company.com

-- 첫 글자만 대문자 (PostgreSQL)
SELECT INITCAP('hello world');
-- 결과: Hello World
\`\`\`

## 문자열 길이

\`\`\`sql
-- 글자 수
SELECT name, LENGTH(name) AS 글자수 FROM employees;
-- 결과: 김철수 → 3

-- 바이트 수 (PostgreSQL)
SELECT OCTET_LENGTH(name) FROM employees;
\`\`\`

## 문자열 추출

\`\`\`sql
-- SUBSTRING(문자열, 시작위치, 길이)
SELECT SUBSTRING(email, 1, 3) FROM employees;
-- 결과: kim

-- LEFT / RIGHT
SELECT LEFT(name, 1) AS 성 FROM employees;
-- 결과: 김
SELECT RIGHT(email, 11) AS 도메인 FROM employees;
-- 결과: company.com
\`\`\`

## 문자열 변환

\`\`\`sql
-- TRIM: 공백 제거
SELECT TRIM('  hello  ');  -- 'hello'
SELECT LTRIM('  hello');   -- 'hello'
SELECT RTRIM('hello  ');   -- 'hello'

-- REPLACE: 문자열 치환
SELECT REPLACE(email, '@company.com', '@newcompany.com')
FROM employees;

-- CONCAT: 문자열 결합
SELECT CONCAT(name, ' (', department, ')') FROM employees;
-- 결과: 김철수 (개발팀)
\`\`\`

## 문자열 검색

\`\`\`sql
-- POSITION: 위치 찾기
SELECT POSITION('@' IN email) FROM employees;
-- 결과: kim@company.com → 4

-- STRPOS (PostgreSQL)
SELECT STRPOS(email, '@') FROM employees;
\`\`\`

## 실용 예제

\`\`\`sql
-- 이메일에서 아이디만 추출
SELECT
    name,
    SUBSTRING(email, 1, POSITION('@' IN email) - 1) AS email_id
FROM employees;

-- 이름 마스킹
SELECT
    LEFT(name, 1) || '**' AS masked_name
FROM employees;
-- 결과: 김**
\`\`\``,
        },

        // 5-2. 숫자/날짜 함수
        {
          id: 'prereq-sql-1-d5-t2',
          title: '숫자와 날짜 함수',
          type: 'reading',
          duration: 30,
          points: 15,
          content: { markdown: `# 숫자와 날짜 함수

## 숫자 함수

\` }\`\`sql
-- 반올림
SELECT ROUND(3.567, 2);  -- 3.57
SELECT ROUND(salary / 3, 0) FROM employees;

-- 올림 / 내림
SELECT CEIL(3.2);   -- 4
SELECT FLOOR(3.8);  -- 3

-- 절대값
SELECT ABS(-100);   -- 100

-- 나머지
SELECT MOD(10, 3);  -- 1

-- 거듭제곱
SELECT POWER(2, 3); -- 8

-- 제곱근
SELECT SQRT(16);    -- 4
\`\`\`

## 집계 함수 (미리보기)

\`\`\`sql
-- 합계
SELECT SUM(salary) FROM employees;

-- 평균
SELECT AVG(salary) FROM employees;

-- 최대/최소
SELECT MAX(salary), MIN(salary) FROM employees;

-- 개수
SELECT COUNT(*) FROM employees;
\`\`\`

## 날짜 함수

\`\`\`sql
-- 현재 날짜/시간
SELECT CURRENT_DATE;      -- 2026-01-15
SELECT CURRENT_TIMESTAMP; -- 2026-01-15 10:30:45

-- 날짜 부분 추출
SELECT EXTRACT(YEAR FROM hire_date) AS 입사년도 FROM employees;
SELECT EXTRACT(MONTH FROM hire_date) AS 입사월 FROM employees;
SELECT EXTRACT(DAY FROM hire_date) AS 입사일 FROM employees;

-- 날짜 계산
SELECT hire_date + INTERVAL '1 year' FROM employees;  -- 1년 후
SELECT hire_date - INTERVAL '30 days' FROM employees; -- 30일 전

-- 날짜 차이
SELECT CURRENT_DATE - hire_date AS 근무일수 FROM employees;
\`\`\`

## 날짜 포맷팅 (PostgreSQL)

\`\`\`sql
-- TO_CHAR: 날짜 → 문자열
SELECT TO_CHAR(hire_date, 'YYYY년 MM월 DD일') FROM employees;
-- 결과: 2020년 03월 15일

SELECT TO_CHAR(hire_date, 'YYYY-MM') AS 입사월 FROM employees;
-- 결과: 2020-03

-- TO_DATE: 문자열 → 날짜
SELECT TO_DATE('2020-03-15', 'YYYY-MM-DD');
\`\`\`

## 실용 예제

\`\`\`sql
-- 근속 연수 계산
SELECT
    name,
    hire_date,
    EXTRACT(YEAR FROM AGE(CURRENT_DATE, hire_date)) AS 근속연수
FROM employees;

-- 이번 달 입사자
SELECT * FROM employees
WHERE EXTRACT(MONTH FROM hire_date) = EXTRACT(MONTH FROM CURRENT_DATE);

-- 급여를 만 단위로 반올림
SELECT name, ROUND(salary, -1) AS 급여 FROM employees;
\`\`\``,
        },

        // 5-3. 함수 실습
        {
          id: 'prereq-sql-1-d5-t3',
          title: 'SQL 함수 종합 실습',
          type: 'code',
          duration: 30,
          points: 20,
          content: { markdown: `# SQL 함수 종합 실습

## 실습 1: 문자열 처리

\` }\`\`sql
-- 1. 이메일 대문자로 변환
SELECT name, UPPER(email) AS email_upper FROM employees;

-- 2. 이름 길이 조회
SELECT name, LENGTH(name) AS 이름길이 FROM employees;

-- 3. 이름 첫 글자만 추출 (성)
SELECT LEFT(name, 1) AS 성, COUNT(*) AS 인원수
FROM employees
GROUP BY LEFT(name, 1);
\`\`\`

## 실습 2: 숫자 계산

\`\`\`sql
-- 1. 평균 급여 계산
SELECT ROUND(AVG(salary), 0) AS 평균급여 FROM employees;

-- 2. 급여 총합
SELECT SUM(salary) AS 급여총합 FROM employees;

-- 3. 가격 반올림 (백원 단위)
SELECT name, price, ROUND(price, -2) AS 반올림가격
FROM products;
\`\`\`

## 실습 3: 날짜 처리

\`\`\`sql
-- 1. 입사년도 추출
SELECT name, EXTRACT(YEAR FROM hire_date) AS 입사년도
FROM employees;

-- 2. 근무일수 계산
SELECT name, CURRENT_DATE - hire_date AS 근무일수
FROM employees;

-- 3. 2020년 입사자
SELECT * FROM employees
WHERE EXTRACT(YEAR FROM hire_date) = 2020;
\`\`\`

## 실습 4: 종합 활용

\`\`\`sql
-- 직원 정보 종합 조회
SELECT
    LEFT(name, 1) || '**' AS 마스킹이름,
    department AS 부서,
    salary AS 월급,
    salary * 12 AS 연봉,
    EXTRACT(YEAR FROM hire_date) AS 입사년도,
    CURRENT_DATE - hire_date AS 근무일수
FROM employees
ORDER BY 근무일수 DESC;
\`\`\``,
        },

        // 5-4. 주간 프로젝트
        {
          id: 'prereq-sql-1-d5-t4',
          title: '주간 프로젝트: 직원 급여 분석 보고서',
          type: 'code',
          duration: 60,
          points: 50,
          content: { markdown: `# 주간 프로젝트: 직원 급여 분석 보고서

## 프로젝트 개요

employees와 products 테이블을 활용하여 데이터 분석 보고서를 작성합니다.

## 과제 1: 직원 현황 분석

\` }\`\`sql
-- 1-1. 전체 직원 수
SELECT COUNT(*) AS 전체직원수 FROM employees;

-- 1-2. 부서별 직원 수
SELECT department, COUNT(*) AS 인원
FROM employees
GROUP BY department
ORDER BY 인원 DESC;

-- 1-3. 급여 통계
SELECT
    COUNT(*) AS 직원수,
    ROUND(AVG(salary), 0) AS 평균급여,
    MAX(salary) AS 최고급여,
    MIN(salary) AS 최저급여,
    SUM(salary) AS 급여총합
FROM employees;
\`\`\`

## 과제 2: 조건별 직원 조회

\`\`\`sql
-- 2-1. 고연봉자 (평균 이상)
SELECT name, department, salary
FROM employees
WHERE salary >= (SELECT AVG(salary) FROM employees)
ORDER BY salary DESC;

-- 2-2. 개발팀 급여 현황
SELECT
    name,
    salary,
    salary * 12 AS 연봉,
    CASE
        WHEN salary >= 5500 THEN '고급'
        WHEN salary >= 5000 THEN '중급'
        ELSE '초급'
    END AS 등급
FROM employees
WHERE department = '개발팀'
ORDER BY salary DESC;

-- 2-3. 최근 입사자 TOP 3
SELECT name, department, hire_date
FROM employees
ORDER BY hire_date DESC
LIMIT 3;
\`\`\`

## 과제 3: 상품 재고 분석

\`\`\`sql
-- 3-1. 카테고리별 상품 현황
SELECT
    category,
    COUNT(*) AS 상품수,
    SUM(stock) AS 총재고,
    ROUND(AVG(price), 0) AS 평균가격
FROM products
GROUP BY category;

-- 3-2. 재고 부족 상품 (50개 이하)
SELECT name, category, stock
FROM products
WHERE stock <= 50
ORDER BY stock;

-- 3-3. 고가 상품 TOP 3
SELECT name, category, price
FROM products
ORDER BY price DESC
LIMIT 3;
\`\`\`

## 과제 4: 종합 보고서 쿼리

\`\`\`sql
-- 4-1. 직원 상세 보고서
SELECT
    name AS 이름,
    department AS 부서,
    salary AS 월급,
    salary * 12 AS 연봉,
    hire_date AS 입사일,
    CURRENT_DATE - hire_date AS 근무일수,
    ROUND((CURRENT_DATE - hire_date) / 365.0, 1) AS 근속년수
FROM employees
ORDER BY 근무일수 DESC;

-- 4-2. 재고 가치 보고서
SELECT
    name AS 상품명,
    category AS 카테고리,
    price AS 단가,
    stock AS 재고수량,
    price * stock AS 재고가치
FROM products
ORDER BY 재고가치 DESC;
\`\`\`

## 제출 체크리스트

- [ ] 모든 쿼리 실행 성공
- [ ] 결과 스크린샷 또는 텍스트 저장
- [ ] 각 쿼리에 주석 추가
- [ ] 추가 분석 쿼리 1개 이상 작성`,
        },

        // 5-5. 주간 퀴즈
        {
          id: 'prereq-sql-1-d5-t5',
          title: 'Week 3 종합 퀴즈',
          type: 'quiz',
          duration: 15,
          points: 25,
          content: { markdown: `# Week 3 종합 퀴즈

이번 주 학습 내용을 종합적으로 확인합니다.` },
          quiz: {
            questions: [
              {
                id: 'q1',
                question: '다음 중 SQL 실행 순서로 올바른 것은?',
                options: [
                  'SELECT → FROM → WHERE',
                  'FROM → SELECT → WHERE',
                  'FROM → WHERE → SELECT',
                  'WHERE → FROM → SELECT',
                ],
                correctAnswer: 2,
                explanation:
                  'SQL 실행 순서: FROM(테이블 선택) → WHERE(필터링) → SELECT(열 선택) → ORDER BY(정렬)',
              },
              {
                id: 'q2',
                question:
                  "SELECT UPPER('hello'), LENGTH('world')의 결과는?",
                options: [
                  'HELLO, 5',
                  'hello, 5',
                  'HELLO, world',
                  '에러',
                ],
                correctAnswer: 0,
                explanation: 'UPPER는 대문자로 변환하고, LENGTH는 문자열 길이를 반환합니다.',
              },
              {
                id: 'q3',
                question:
                  '2020년 이후 입사자를 조회하는 올바른 WHERE 조건은?',
                options: [
                  "hire_date = '2020'",
                  "hire_date > '2020-01-01'",
                  "YEAR(hire_date) >= '2020'",
                  "hire_date LIKE '2020%'",
                ],
                correctAnswer: 1,
                explanation:
                  "날짜 비교는 비교 연산자를 사용합니다. hire_date > '2020-01-01'이 올바른 방법입니다.",
              },
              {
                id: 'q4',
                question:
                  'SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 3의 결과는?',
                options: [
                  '급여가 가장 낮은 3명',
                  '급여가 가장 높은 3명',
                  '이름순 상위 3명',
                  '랜덤 3명',
                ],
                correctAnswer: 1,
                explanation:
                  'ORDER BY salary DESC는 급여 내림차순 정렬, LIMIT 3은 상위 3개 결과만 반환합니다.',
              },
              {
                id: 'q5',
                question: 'COUNT(DISTINCT department)와 COUNT(department)의 차이는?',
                options: [
                  '차이 없음',
                  'DISTINCT는 고유값만 카운트',
                  'COUNT는 NULL 포함',
                  'DISTINCT는 더 느림',
                ],
                correctAnswer: 1,
                explanation:
                  'COUNT(DISTINCT column)는 중복을 제거한 고유값의 개수를, COUNT(column)는 전체 행 수를 반환합니다.',
              },
            ],
          },
        },
      ],
    },
  ],
  resources: [
    {
      title: 'W3Schools SQL Tutorial',
      url: 'https://www.w3schools.com/sql/',
      type: 'documentation',
    },
    {
      title: 'SQLBolt - Interactive SQL Lessons',
      url: 'https://sqlbolt.com/',
      type: 'tutorial',
    },
    {
      title: 'PostgreSQL 공식 문서',
      url: 'https://www.postgresql.org/docs/',
      type: 'documentation',
    },
    {
      title: 'Mode Analytics SQL Tutorial',
      url: 'https://mode.com/sql-tutorial/',
      type: 'tutorial',
    },
  ],
  commonPitfalls: [
    {
      title: '작은따옴표 vs 큰따옴표',
      description: "문자열 값은 반드시 작은따옴표를 사용합니다. department = '개발팀' (O), department = \"개발팀\" (X)",
    },
    {
      title: 'NULL 비교 오류',
      description:
        'NULL은 = 연산자로 비교할 수 없습니다. column = NULL (X), column IS NULL (O)',
    },
    {
      title: 'ORDER BY 위치',
      description: 'ORDER BY는 반드시 쿼리의 마지막에 위치해야 합니다. WHERE 전에 쓰면 에러 발생.',
    },
    {
      title: 'LIMIT 없는 대용량 조회',
      description: '대용량 테이블에서 SELECT * 사용 시 반드시 LIMIT을 추가하세요. 시스템 과부하 위험.',
    },
  ],
}
